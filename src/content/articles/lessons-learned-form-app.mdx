---
draft: false
title: 'Lessons learned: FormApp'
snippet:
    'Czy szukanie pomysłów na aplikację jest trudne? Niekoniecznie. Jestem pewien, że po chwili zastanowienia będziesz zmuszony wybrać jeden, który chcesz wdrożyć z puli kilkunastu. Pokażę Ci, w jaki sposób sam szukam inspiracji.'
publishDate: '2024-07-30'
cover: { src: './lessons-learned-form-app-cover.jpg', alt: '' }
---
import { Image } from 'astro:assets';
import structure from './lessons-learned-form-app-1.png';
import queriesStructure from './lessons-learned-form-app-2.png';
import request from './lessons-learned-form-app-3.png';

Pozornie prosty pomsył może szybko przekształcić się w potworka na którego nie chce się patrzeć. Zwłaszcza jeżeli postanowisz zastosować w nim kilka nowych rozwiązań, które niekoniecznie są przemyślane.

FormApp to aplikacja służąca do udostępniania harmonogramu wizyt wraz z formularzem zapisu. Zasada działania jest prosta - podczas rejestracji wybierasz swoją subdomenę, tworzysz harmonogram z wizytami a następnie go publikujesz. Najbardziej spójny efekt uzyskasz rejestrując subdomenę identyczną z Twoją stroną, np. krzysztofadamczak.formapp.pl. Później udostępniasz link i użytkownicy mogą zapisywać się na konkretne godziny a Ty zobaczysz nadchodzące wizyty w swoim panelu administracyjnym.

Pomysł wydawał mi się stosunkowo prosty, dlatego pominąłem fazę jakiegokolwiek rozeznania się temacie i przeszedłem od razu do edytora. Plus miałem kilka pomysłów na usprawnienia względem poprzedniego projektu. Co może pójść źle?


## Struktura projektu
Na przestrzeni czasu wypracowałem strukturę która opiera się funkcjach projektu. Myślę, że sprawdza się lepiej niż wrzucanie wszystkiego do jednego folderu _components_. Największe bolączki takiej organizacji plików to podjęcie decyzji kiedy należy wydzielić folder na osobną funkcjonalność i kiedy należy dzielić plik na mniejsze części.

<Image class='mx-auto' src={structure} alt="Przykładowa struktura moich projektów" />

Pisząc FormApp postanowiłem pójść krok dalej i rozdzielić zapytania o konkretne zasoby do osobnych plików. Przede wszystkim dlatego, że używałem ich zarówno w _client components_ jak i _server components_. Zamiast śledzić zmiany w jednym miejscu, byłem zmuszony przeskakiwać między kolejnymi plikami. Czy duże pliki naprawdę są problemem? Uważam, że nie. Ciągła zmiana kontekstu jest dla mnie trudniejsza niż przeszukanie dużego pliku. Nikt raczej nie powinien trzymać większego projektu w jednym pliku, ale nie widzę też sensu w rozdzielaniu wszystkiego na coraz drobniejsze elementy.

<Image class='mx-auto' src={queriesStructure} alt="Nowy pomysł rozdzielenia zapytań o zasoby" />

## Supabase
A dokładniej dodanie pośrednika między klientem a Supabase w postaci własnego serwera. poszczególne tabele w bazie danych były publicznie dostępne do modyfikacji jak i odczytu, np. zapisywanie umówionych wizyt czy pobieranie listy zarejestrowanych subdomen. Nie chcąc udostępniać adresu Supabase wszystkie operacje wykonywałem po stronie serwera. Droga takiego żądania wyglądała następująco.

<Image class='mx-auto' src={request} alt="Długa droga żądania" />

Ustawienie serwera i Supabase w takiej samej lokalizacji z pewnością zmniejszyłoby problem opóźnień, ale niestety nie mogłem skorzystać z takiego rozwiązania. W tym wypadku wolałbym całkowicie pominąć klienta Supabase.

## i18n
W tym wypadku nie jestem w stanie jednoznacznie określić, czy rozwiązanie na które się zdecydowałem jest plusem, czy minusem. Tłumaczenia w SPA to skomplikowany temat i nie sądzę, że ktoś lubi się nim zajmować. Nowy paradygmat w postaci _server components_ dodatkowo go nie ułatwia. W aplikacjach które tworzę nie potrzebuję zaawansowanego systemu tłumaczeń jaki oferuje i18next czy next-intl. Zamiast tego dla każdego komponentu w którym potrzebuję tłumaczeń tworzę plik json o następującej strukturze.

```json
{
    "pl": {
        "example": "Jakieś zdanie",
    },
    "en": {
        "example": "Some sentence",
    }
}
```

I wykorzystuję go tak.

```tsx
import SchedulesDict from '@/dictionaries/SchedulesDict.json';

const Schedules = () => {
    const locale = useLocaleContext();

    const t = SchedulesDict[locale];

    return (
        <div>
            {t.example}
        </div>
    )
}
```

## Podsumowanie
Ta krótka retrospekcja skłania mnie do jednej refleksji. Doszliśmy do momentu, w którym bez 10 bibliotek w _package.json_ nie zaczynamy nawet projektu. Stopień skomplikowania odzwierciedla się również w ankietach. State Of JS pokazuje ciągły spadek zadowolenia z front-endowych frameworków od 2018 roku. A gdyby tak spróbować prościej?